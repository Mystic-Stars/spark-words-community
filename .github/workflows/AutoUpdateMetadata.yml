name: Auto Update Metadata

on:
  push:
    paths:
      - 'papers/**/*.json'
    branches:
      - main
      - master
  pull_request:
    paths:
      - 'papers/**/*.json'
  workflow_dispatch:  # ÊîØÊåÅÊâãÂä®Ëß¶Âèë

jobs:
  validate-and-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.head_ref || github.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Validate JSON files
        run: |
          echo "üîç Validating JSON files..."
          
          # ÈÄíÂΩíÊü•ÊâæÊâÄÊúâ JSON Êñá‰ª∂ÔºàÊîØÊåÅÂ≠êÊñá‰ª∂Â§πÔºâ
          find papers -name "*.json" -type f | while read file; do
            if [ "$file" == "papers/metadata.json" ]; then
              continue
            fi
            
            echo "Checking: $file"
            
            # Ê£ÄÊü• JSON Ê†ºÂºè
            if ! jq empty "$file" 2>/dev/null; then
              echo "‚ùå Invalid JSON format: $file"
              exit 1
            fi
            
            # Ê£ÄÊü•ÂøÖÂ°´Â≠óÊÆµ
            if ! jq -e '.id and .title and .questions' "$file" > /dev/null; then
              echo "‚ùå Missing required fields (id, title, questions) in: $file"
              exit 1
            fi
            
            # Ê£ÄÊü• questions Êï∞ÁªÑ‰∏ç‰∏∫Á©∫
            question_count=$(jq '.questions | length' "$file")
            if [ "$question_count" -eq 0 ]; then
              echo "‚ùå No questions found in: $file"
              exit 1
            fi
            
            echo "‚úÖ $file is valid ($question_count questions)"
          done
          
          echo "‚úÖ All JSON files are valid!"
      
      - name: Auto update metadata.json
        run: |
          echo "üìù Updating metadata.json..."
          
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // ÈÄíÂΩíÊâ´ÊèèÁõÆÂΩï‰∏ãÁöÑÊâÄÊúâ JSON Êñá‰ª∂
          function getAllJsonFiles(dir, baseDir = dir) {
            let results = [];
            const list = fs.readdirSync(dir);
            
            for (const file of list) {
              const filepath = path.join(dir, file);
              const stat = fs.statSync(filepath);
              
              if (stat.isDirectory()) {
                // ÈÄíÂΩíÊâ´ÊèèÂ≠êÊñá‰ª∂Â§π
                results = results.concat(getAllJsonFiles(filepath, baseDir));
              } else if (file.endsWith('.json') && file !== 'metadata.json') {
                // ËÆ°ÁÆóÁõ∏ÂØπË∑ØÂæÑÔºàÁõ∏ÂØπ‰∫é papers ÁõÆÂΩïÔºâ
                const relativePath = path.relative(baseDir, filepath).replace(/\\/g, '/');
                results.push({
                  filename: file,
                  filepath: filepath,
                  relativePath: relativePath,
                });
              }
            }
            
            return results;
          }
          
          // ËØªÂèñÂΩìÂâç metadata.json
          const metadataPath = 'papers/metadata.json';
          let metadata = { papers: [], lastUpdated: new Date().toISOString() };
          
          if (fs.existsSync(metadataPath)) {
            try {
              metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
            } catch (error) {
              console.log('‚ö†Ô∏è  metadata.json is invalid, creating new one');
            }
          }
          
          // Êâ´Êèè papers ÁõÆÂΩï‰∏ãÁöÑÊâÄÊúâ JSON Êñá‰ª∂ÔºàÂåÖÊã¨Â≠êÊñá‰ª∂Â§πÔºâ
          const papersDir = 'papers';
          const allFiles = getAllJsonFiles(papersDir);
          
          console.log(`üìö Found ${allFiles.length} paper file(s)`);
          if (allFiles.length > 0) {
            console.log('üìÇ File structure:');
            allFiles.forEach(f => console.log(`   - ${f.relativePath}`));
          }
          
          // ÊûÑÂª∫Êñ∞ÁöÑ papers ÂàóË°®
          const newPapers = [];
          const processedIds = new Set();
          
          for (const fileInfo of allFiles) {
            try {
              const paper = JSON.parse(fs.readFileSync(fileInfo.filepath, 'utf8'));
              
              // Ê£ÄÊü•ÈáçÂ§ç ID
              if (processedIds.has(paper.id)) {
                console.error(`‚ùå Duplicate paper ID found: ${paper.id} in ${fileInfo.relativePath}`);
                process.exit(1);
              }
              processedIds.add(paper.id);
              
              // Êü•ÊâæÊòØÂê¶Â∑≤Â≠òÂú®
              const existing = metadata.papers.find(p => p.id === paper.id);
              
              if (existing) {
                // Êõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩï
                newPapers.push({
                  id: paper.id,
                  title: paper.title,
                  description: paper.description || existing.description || '',
                  author: paper.author || existing.author || 'Anonymous',
                  tags: paper.tags || existing.tags || [],
                  difficulty: paper.difficulty || existing.difficulty || 'other',
                  questionCount: paper.questions?.length || 0,
                  filepath: `papers/${fileInfo.relativePath}`,
                  createdAt: existing.createdAt || paper.createdAt || new Date().toISOString(),
                  updatedAt: new Date().toISOString(),
                  version: paper.version || existing.version || '1.0.0',
                });
                console.log(`üìù Updated: ${paper.title} (${paper.questions?.length || 0} questions)`);
              } else {
                // Ê∑ªÂä†Êñ∞ËÆ∞ÂΩï
                newPapers.push({
                  id: paper.id,
                  title: paper.title,
                  description: paper.description || '',
                  author: paper.author || 'Anonymous',
                  tags: paper.tags || [],
                  difficulty: paper.difficulty || 'other',
                  questionCount: paper.questions?.length || 0,
                  filepath: `papers/${fileInfo.relativePath}`,
                  createdAt: paper.createdAt || new Date().toISOString(),
                  updatedAt: new Date().toISOString(),
                  version: paper.version || '1.0.0',
                });
                console.log(`‚ú® Added new: ${paper.title} (${paper.questions?.length || 0} questions)`);
              }
            } catch (error) {
              console.error(`‚ùå Error processing ${fileInfo.relativePath}:`, error.message);
              process.exit(1);
            }
          }
          
          // ÊåâÂàõÂª∫Êó∂Èó¥ÊéíÂ∫èÔºàÊúÄÊñ∞ÁöÑÂú®ÂâçÔºâ
          newPapers.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
          
          // Êõ¥Êñ∞ metadata
          metadata.papers = newPapers;
          metadata.lastUpdated = new Date().toISOString();
          
          // ÂÜôÂÖ•Êñá‰ª∂
          fs.writeFileSync(
            metadataPath,
            JSON.stringify(metadata, null, 2) + '\n',
            'utf8'
          );
          
          console.log(`‚úÖ Updated metadata.json with ${newPapers.length} paper(s)`);
          console.log(`üìä Statistics:`);
          console.log(`   - Total papers: ${newPapers.length}`);
          console.log(`   - Total questions: ${newPapers.reduce((sum, p) => sum + p.questionCount, 0)}`);
          
          const difficulties = newPapers.reduce((acc, p) => {
            acc[p.difficulty] = (acc[p.difficulty] || 0) + 1;
            return acc;
          }, {});
          console.log(`   - By difficulty:`, difficulties);
          EOF
      
      - name: Commit changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add papers/metadata.json
          
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è  No changes to metadata.json"
          else
            git commit -m "chore: auto-update metadata.json [skip ci]"
            git push
            echo "‚úÖ metadata.json has been updated and pushed"
          fi
      
      - name: Summary
        run: |
          echo "## ‚úÖ Workflow completed successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All JSON files have been validated and metadata.json has been updated." >> $GITHUB_STEP_SUMMARY
